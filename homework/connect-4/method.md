# 	connect-four

[Eren Zhao](https://zhaochenyang20.github.io/)

# 游戏规则

## 基础规则

游戏双方分别持不同颜色的棋子，设 A 持白子，B 持黑子，以某一方为先手依次落子。假设为 A 为先手，落子规则如下：

在 M 行 N 列的棋盘中，棋手每次只能在每一列当前的最底部落子，如图中的红点处所示，如果某一列己 经落满，则不能在该列中落子。在图形界面中，如果在某一列的任意一个按钮上点击，会自动在该列的最低端落子。

棋手的目标是在横向、纵向、两个斜向共四个方向中的任意一个方向上，使自己的棋子连成四个（或四个以上），并阻止对方达到同样的企图。先形成四连子的一方获胜，如果直到棋盘落满双方都没能达到目标，则为平局。

## 扩展规则

1. **棋盘的大小是随机的，而不是固定不变的，宽度和高度的范围均为 $[9, 12]$。**由于并不是所有规模的棋盘都有必胜策略，也不是所有的必胜策略都是先手必胜，所以这里带来了不确定因素。你应该使自己的算法尽可能普适。

2. 每次棋盘生成之后，会同时在棋盘上随机生成一个不可以落子的位置。

# 文件信息

## judge

用来进行胜局检测的函数，你可能使用得到也可能使用不到，相关函数的具体说明请见代码中的详细注释。这里只强调一些细节：

1. 由于在某一方落子得胜之前，一定不可能出现过任何一方的胜局，所以我们只需要在某次落子之后，以本次落子点为核心判断是否有多于四个的连子即可。userWin 函数和 computerWin 函数就是这样做的，并且我们只需要在 user 落子时候判断是否 userWin，在 computer 落子之后判断是否 computerWin。 
2. isTie 通过检测棋盘是否己满来判断是否为平局，这就意味着调用 isTie 必须在调用 userWin 或 computerWin 之后。假如某次为用户落子，那么之后 userWin 为 false 时，调用 isTie 进行判断才有意义。

## point

Point 类，用来记录棋盘上的一个点。

棋盘左上角为坐标原点，纵向为 x 轴，横向为 y 轴，（x, y）点对应于棋盘中第 x 行第 y 列的位置（从 0 开始）。

## strategy

**定义了策略函数同外部调用程序之间的接口。**

getPoint 函数：在对抗时，外部程序在每次需要落子时通过调用该函数获得你给出的落子点。你的策略最终应当封装到该函数中，给出你在本步中的落子。

clearPoint 函数：策略模块中动态定义的对象必须由策略模块中的函数来释放；getPoint 函数返回一个 Point *，该指针指向的对象应当通过在外面调用clearPoint 函数来释放。**你不需要修改该函数。**

## 注意事项

1. 接口

  >1. top 数组给定了当前棋局各列的顶端位置，这些顶端的上面是你可以落子的地方。如果你的策略给出了非法的落子，那么程序会给出提示。
  >2. board 二维数组则给出了当前棋局的所有情况。你可以假设自己策略正在同某一用户进行对弈，那么 board 中 0 为空位置，1 为有用户棋子的位置，2 为有计算机（自己的策略）的棋。不可落子点处的 board 值也为 0。 
  >3. **对于不可落子点，外部调用程序己经做出了处理。**比如某次落子点为 A 位置，而 A 上面的 B 位置为不可落子点，那么下次传递给你的 top 数组中该列列顶己被设为了 B，而不是 A，**所以你的策略中不需要考虑对不可落子点进行特殊处理**。不可落子点 (noX, noY) 在参数列表内。
  >4. 实际操作时，请注意看代码中详细的注释。这将对你理解整个项目有很大的帮助。
  >

2. 最好用 Release 模式编译以保证你的落子速度。**打印操作会严重影响你的策略的速度，所以在最终版本中请务必去掉所有的打印调试信息。**

3. 不要随意修改工程的各种属性。

4.  (lastX, lastY) 给出了上一次对方落子的位置，刚开局时传入的 lastX 和 lastY 值为 -1。当然，为了更好地组织你的策略，你可以不仅仅利用上一次落子这一步信息，而且在你的策略中将其保存下来，综合多步以便决策时使用。实际上，传入的参数中 top 和 board 给定了当前的状态，lastX、lastY 给定了过去的过程，这样也就为你提供了全部可用信息。

5. 请务必于 DDL 前在小组作业内派遣自己最终版本的 AI。在「我的AI」页面派遣的 AI 不作为提交的依据。


# 平台信息

## 在线对战

除了排行榜和 AI 列表中的「快速人机对局」功能外。使用 Saiblo 平台的[房间系统](https://www.saiblo.net/rooms)也可以进行人机/机机/人人对战。

进入房间列表后，选择服务器 `ailab`，点击创建房间即可创建一个房间。在任意空座位上，你可以

- 添加 AI：点击「添加 AI」，选择自己的 AI 或者使用 AI Token 加入 AI（Token 可以在我的 AI 中找到并复制，也可以在排行榜上复制其他选手的 AI Token）。
- 在线游玩：点击「加入游戏」并点击准备，即可以人类身份开始游戏。

当所有位置上的 AI 准备好后，房主点击「开始游戏」按钮即可开始游戏，游戏结束后，会自动跳转到对局详情页面。

## 批量测试

我们提供了批量测试功能以便系统性的评估 AI 水平。具体地，在我的 AI 列表中编译成功的 AI 右边点击批量测试按钮，即可配置批量测试。点击提交后会跳转到批量测试详情页面，在这里可以查看本次批量测试的详细对局情况，包括胜、负、平和胜率。

由于批量测试规模较大，且一局四子棋评测往往耗时 3-5 分钟，极为消耗测评机资源，在批量测试时可能出现排队的情况，请耐心等待。此外，为了防止测评机负荷过大，限制每人每天可与不超过 100 个 AI 进行批量测试，每日凌晨某个时间刷新测试额度。

## 大作业最终评测

**派遣到课程小组“四子棋作业”比赛内的代码即为作业提交代码**，作用相当于“标记为最终版本”，DDL前可随时更改，DDL后无法再从网站更改。

AI 在运行时，限制每回合 3s 运行时间（以 CPU 时间为准）。此外，**与往年不同的是**，平台上限制峰值内存 1GB，由于**最终评测也在平台上进行**，请保证自己的程序运行时不会消耗过多内存从而出现 MLE（Memory Limit Exceeded）错误。

为了便于同学监控 AI 的每回合的运行情况，在对局详情页面，我们提供了回合级别的的 AI 运行时间与内存统计。

此外，根据往年经验，由于 Linux 下内存访问较为严格，其余平台下对指针操作存在 BUG 的代码（常见于指针删除逻辑）在 Linux 下运行时容易出现运行时错误。为了避免最终评测中出现意外情况，请在平台上**充分测试**(例如用批量测试功能与50个样例AI对战)。

**注意：**在回合内存统计的时候，我们使用 cgroup 的 `memory.max_usage_in_bytes` 参数统计程序使用内存。

简单来说，如果在程序中申请了一个应该一开始就 MLE 的大数组，在我们的统计中并不会立即显示出 MLE，而是实际使用多大就统计出多大。然而随着回合数增多，可能出现 MLE 的情况，在编写程序时请格外注意。

## 调试

1. 与 `cout` 类似，你可以使用 `cerr` 将调试信息输出到 `stderr` 从而在网站的对局详情页面中查看程序运行时输出的调试信息。注意输出的信息不要超过 Linux 管道的缓冲区大小 64KB，否则可能会出现阻塞而导致运行超时。
2. 建议在最终版本 AI 中去掉所有调试信息，为自己争取更多的计算时间。请勿使用 cout 等向 stdout 输出调试信息，否则可能导致你的 AI 无法在平台上正确运行。

## compare

1. Compete 项目是一个非界面、命令行式的对抗平台，可执行程序允许你将两个策略文件进行指定轮数的对抗，并给出结果统计。

2. 首先编译自己的 Strategy 项目，得到自己的策略文件，然后调用 Compete 项目下的可执行文件进行对抗测试。

评测框架位于 `Compete` 文件夹下，该文件夹内容如下

```bash
Compete
├── Compete.cpp
├── Compete.h
├── Data.h
├── Exception.hpp
├── Judge.cpp
├── Judge.h
├── Point.h
├── main.cpp
└── makefile
```

使用 `make` 编译得到可执行程序 `Compete`， `Compete` 程序的使用方法如下

```bash
./Compete	<A的so文件路径> <B的so文件路径>	<结果文件名>	<对抗轮数>
```

A 和 B 使用完全相同的初始棋盘对抗指定轮数，每轮两次，分别为 A 先手和 B 先手。

对局结果存放在<结果文件名>指定的文件中，每轮的结果存放格式为：

```
结果 A的时间(s) B的时间(s)	// A 先手时
结果 A的时间(s) B的时间(s)	// B 先手时
```

文件会最后给出总的结果统计情况，注意只有当程序的返回值为 0/1/2 时，时间才有意义。

程序的返回值意义如下：

- 0 : 平局
- 1 : A 胜出，结束
- 2 : B 胜出，结束
- 3 : A 出bug，结束
- 4 : A 做出了非法的落子，结束
- 5 : B 出 bug，结束
- 6 : B 做出了非法的落子，结束
- 7 : A 超时
- 8 : B 超时
- -1 : 载入文件 A 出错
- -2 : 载入文件 B 出错
- -3 : A 文件中无法找到需要的函数接口
- -4 : B 文件中无法找到需要的函数接口

**注意：**由于 `dlopen` 并不会搜索当前文件夹下的 so 文件，若要加载同文件夹下的 so 文件，请在路径前面加入 `./`，即使用 `./ai.so` 表示 so 文件路径。

   ## batch

   采用基于 linux 系统的批量编译、对抗脚本，需要将脚本中的待编译文件及编译器路径修改为本地目录，同时指定对抗轮数等参数。具体使用方法见各

   自系统目录下 readme.txt 文件。

## 时空限制

- 最大内存 1GB
- 单回合最长时间 3s
- 上传代码大小不超过 64MB
- 输出调试信息总大小不超过 64 KB
- 单步落子的时限定为 3s，这个时限仅仅是为了对死掉的程序进行处理，所以为了保险起见，建议你不要为了搜的更 深而让自己的程序单步时间特别接近3s，考虑到测试服务器的性能在不同运行环境下有可能不同，所以特别接近于 3s 将是危险的。

