# **Segement Me If U Can**

THUCST Intro to AI PA 2

[Eren zhao](https://zhaochenyang20.github.io/) Class 06

# 任务简介

- 进行一次情感二分类，仅考虑正负情感。

## 实验数据
- 实验数据包括包含训练、验证、测试集合以及预处理好的词向量
- 句子的分类包含正向和负向两种

## 实验要求
- 本次实验要求实现 CNN 与 RNN 两个模型，并应用在情感分类任务上。RNN 可以是 LSTM，GRU 等类型。
- 对比两模型的实验效果，并分析原因。 也可以实现其他模型作为对比模型（baseline），例如全连接神经网络（MLP），可适当加分。

## 评价指标

1. 准确率（Accuracy）
2. [F-score](https://deepai.org/machine-learning-glossary-and-terms/f-score)，类似 MIOU

## 报告内容
1. 模型的结构图，以及流程分析。
2. 实验结果，准确率，F-score 的实验效果。
3. 试简要地比较实验中使用的不同参数效果，并分析原因。
4. 比较 baseline 模型与 CNN，RNN 模型的效果差异。（如果有实现）
5.  问题思考，心得体会

## Question List

1. 实验训练什么时候停止是最合适的？简要陈述你的实现方式，并试分析固定迭代次数与通过验证集调整等方法的优缺点。
2. 实验参数的初始化是怎么做的？不同的方法适合哪些地方？（现有的初始化方法为零均值初始化，高斯分布初始化，正交初始化等）
3. 过拟合是深度学习常见的问题，有什么方法可以防止训练过程陷入过拟合
4. 试分析CNN，RNN，全连接神经网络（MLP）三者的优缺点

# 模型结构

## Bi-LSTM

![LSTM](https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/LSTM.jpg)

- 双向 LSTM 分类网络的模型结果如上图。前向传播的流程为：将一批长度统一且标记化的句子输入网络，依次经过：
1. 嵌入层：将每个表示单词的自然数映射为指定长度的向量，即用向量表示单词。
2. 双向双层 LSTM 层：接收某个 batch 的词向量组成的序列，每个 LSTM 单元在两个方向上分别产生自己的隐藏状态。最终只用了最后一层（第二层）两个方向上传播的各自的最后一个单元的隐藏状态作为下一层的输入。
3. 线性分类层：由两层网络构成，接收上述 LSTM 层产生的两个隐藏状态直接拼接起来的向量（维数变为隐藏状态维数的 2 倍）作为输入，经过两层线性层输出维数等于分类类别数的向量，表示对类别的预测结果。
4. 在 Bi-LSTM 的基础上，将 LSTM 单元替换为 GRU 单元即可得到基于 LSTM 变种 [GRU](https://towardsdatascience.com/understanding-gru-networks-2ef37df6c9be) 实现的 RNN，此处不再赘述。

![GRU](https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/GRU.svg)

## Text-CNN

<img src="https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/CNN.jpg" alt="CNN" style="zoom:50%;" />

- 依据[参考文献](https://arxiv.org/abs/1408.5882)中的模型搭建 Text-CNN 模型。前向传播流程如下：
1. 嵌入层：将每个表示单词的自然数映射为指定长度的向量，即用向量表示单词。
2. 一维多通道多卷积核卷积层：将嵌入层得到的数据视为一批多通道的一维张量；一维张量的长度为对齐后的句子长度，通道数为词向量的数。用指定数量与大小的卷积核与输入数据做多通道多卷积核卷积，得到多通道的一维输出特征。用宽度为3、5、7的卷积核分别做三次卷积。
3. 池化层：对卷积结果进行 activate, Dropout, max pooling。
4. 线性层：将池化后的卷积结果拼接在一起，得到长度为所有卷积输出通道数之和的张量，再经过一层线性层得到表示类别标签预测的向量。

## MLP

<img src="https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/MLP.jpg" alt="MLP" style="zoom:50%;" />

使用 MLP 作为 baseline 。模型示意图如上，前向传播大致流程如下：
1. 嵌入层：将每个表示单词的自然数映射为指定长度的向量，即用向量表示单词。
2. 线性层1：接收一批将句子中的词向量直接拼接起来得到的张量为输入，输出指定大小的张量，然后进行 Batch Normalization, Activation, Dropout。
3. 线性层2：输出表示类别标签预测的向量。

# 配置信息

## 环境库
参考 requirements.txt
## 可视化
采用 [wandb](https://wandb.ai/site) 辅助可视化
## 算力
由于我自己的电脑是 Macbook M1 Core，虽然 M1 芯片优化了 CPU 计算的性能，然而没有显卡是硬伤。于是我在自己的服务器上进行训练，服务器有 1 张 3080。

# 实验结果

##  模型对比

对比正确率以及训练过程中损失值和验证集上的正确率随训练时间推移的关系（如下图，由 wandb 生成；损失值为每优化一步时模型返回的结果，验证集的准确率为每一 epoch 衡量一次），可以对四种模型进行比较。

此处展示 f1_score 和 accuracy 与 CrossEntropyLoss 的 loss。

### accuracy

<img src="https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/acc1.png" style="zoom:13%;" />

<img src="https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/acc2.png" style="zoom:13%;" />

<img src="https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/acc3.png" style="zoom:13%;" />

### f1_score

<img src="https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/f11.png" style="zoom:13%;" />

<img src="https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/f12.png" style="zoom:13%;" />

<img src="https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/f13.png" style="zoom:13%;" />

### loss

<img src="https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/loss1.png" style="zoom:13%;" />

<img src="https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/loss2.png" style="zoom:13%;" />

<img src="https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/loss3.png" style="zoom:13%;" />

其中对于 f1_score 与 accuracy，四个模型在我所选取的参数下的最佳结果为：

|          | Text-CNN | RNN-GRU | RNN-LSTM | MLP    |
| -------- | -------- | ------- | -------- | ------ |
| accuracy | 0.8618   | 0.8482  | 0.8455   | 0.813  |
| f1_score | 0.864    | 0.8526  | 0.8512   | 0.8089 |

结合评价指标与上图，可以观察出：

- RNN 的损失值下降最快，收敛最快，正确率在 Text-CNN 与 MLP 之间，然而过拟合现象出现最快
- CNN 的损失值下降居中，正确率最高，过拟合现象最不明显（经过 100 个 epoch 的实验证明，Text-CNN 的正确率从 25 个 epoch 左右开始收敛到 0.847）
- MLP 损失函数下降速度、收敛速度最慢，正确率最低，过拟合的程度居于 Text-CNN 与 RNN 之间。

## 参数对比

大量的参数让我感到调参工作的艰巨，最让我感到震撼的是我对 max_length 参数的调配。

### max_length

Max_length 参数用于控制句子的最长词向量个数，我起初将其设置为 50，也即设置为与词向量维度相同，这样以来，input matrix 的 size 为 50*50，这样做的效果如下表格所示：

|          | Text-CNN | RNN-GRU | RNN-LSTM | MLP    |
| -------- | -------- | ------- | -------- | ------ |
| accuracy | 0.8618   | 0.8482  | 0.8455   | 0.813  |
| f1_score | 0.864    | 0.8526  | 0.8512   | 0.8089 |

然而，我与同学交流后得知，经过人工核实数据集后发现，只有一条语句长度为 600+，其余语句长度均低于 120。转念一想，我认为自己丢失了大量的语句信息，于是考虑将 max_length 调整为 120。期望能够为模型带来巨大突破，然而结果如下：
|          | Text-CNN | RNN-GRU | RNN-LSTM | MLP    |
| -------- | -------- | ------- | -------- | ------ |
| accuracy | 0.8509   | 0.8564  | 0.8509   | 0.8347 |
| f1_score | 0.8501   | 0.8638  | 0.8415   | 0.8329 |

实际上并未出现我所设想的巨大突破（譬如突破到 90 点以上），甚至在 Text-CNN 上反而结果下降。起初，我认为一个句子仅仅截断前 50 个单位是很难表达句子全意的，很有可能会误判“欲扬先抑”这样的语义。然而再一设想，考虑到此处的词向量单位是汉语中的词语而非汉字，实际上在较短篇幅的评论中，即便是欲扬先抑，也很难会有超过 50 个词语的铺垫，反而由于输入矩阵的大小倍增，导整体的计算效率有一定降低。再三思考，我并未取用 max_length = 120，而是保持了 50。

真正决定了训练效果无法突破 90 大关的是模型本身与预训练模型，而这些精细的调整并未能触碰到 90 大关。

### 初始学习率

以 CNN 为例，调整 Adam 优化器的初始学习率，检测测试集上的正确率：
<img src="https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/test_learning_rate.png" style="zoom:13%;" />

可见，Adam 优化器默认提供的 0.001 的学习率是一个比较好的值。学习率过大或者过小都会影响训练效果；前者使得神经网络每次优化跨度太大，反而难以找到极小值；后者会使神经网络收敛速度太慢。

# 问题思考

## 实验停止

实验训练什么时候停止是最合适的？简要陈述你的实现方式，并试分析固定迭代次数与通过验证集调整等方法的优缺点。

在尚未确定以 10 为最终 epoch  前，起初我设置了一个最大值闸值 max_epoch = 10。在无限次训练的情况下，倘若连续 max_epoch 次训练都没能超越之前记录的最大 test_acc 值即停止训练，然而经过数次尝试且调整 max_epoch 后，我发现训练的最大值均在前 10 个 epoch 就会取得，其后均是波动而收敛，例如经过无限个 epoch 的实验证明，Text-CNN 的正确率从 25 个 epoch 左右开始收敛到 0.847，而 MLP 从 33 个 epoch 之后开始收敛到 0.772）

这样的结果无疑让我感到诧异，我最终选择了仅仅保留十个 epoch 的做法，似乎这样此次实验不需追求自动化停止训练。然而在实际的科研应用中，自动化停止训练是非常必要的，否则会浪费大量的计算资源。

我认为，可以先简单的考虑人工观察训练情况。利用 wandb 的可视化功能进行观察。如果训练集上的 loss 在下降而验证集上的正确率在上升，则需要继续训练。直到训练集上的 loss 在下降（或者几乎不变）而验证集上的正确率也在下降，说明出现了过拟合，那么此时即可停止训练，因为继续下去得到的模型是性能表现并不好的过拟合的模型。

## 参数初始化

本次实验中，RNN 与 CNN 的参数均为 kaiming 初始化，而 MLP 采用高斯初始化。

1. 在回答问题前，我先叙述两次我在本次实验当中失败的参数初始化：

首先是我在 MLP 的模型设计中，采用了初始化参数全 0 与全 1 的设定，导致模型完全没法训练。后来才发现这是深度学习的经典错误。

此处以三层神经网络为例，分析为何不可全 0 初始化。

<img src="https://zhaochenyang20.github.io/pic/lecture/2022_spring/IAI/three_layer.jpg" style="zoom:13%;" />

其中，$z_4、z_5、z_6$ 可表达为:

$$
z_4 = w_{14} * x_1 + w_{24} * x_2 + w_{34} * x_3 + b_4 \ z_5 = \\w_{15} * x_1 + w_{25} * x_2 + w_{35} * x_3 + b_5 \ z_6 = w_{16} * x_1 + w_{26} * x_2 + w_{36} * x_3 + b_6 \
$$
由于权重和偏置的初始值都为0，且同一层网络的激活函数相同，则有：
$$
z_4 = z_5 = z_6 \ a_4 = a_5 = a_6
$$
对于神经网络的最终输出 $a_7$，我们可以得到：
$$
\begin{align} z_7 &= w_{47} * a_4 + w_{57} * a_5 + w_{67} * a_6 \ a_7 = f(z_7) \end{align}
$$
其中，$f(\cdot)$为第三层网络的激活函数。

假设真实值为 $y$, 损失函数为 $Loss(a_7, y)$，根据反向传播算法和链式法则，我们可以得到：

$$
\begin{align} \frac{\partial Loss(a_7,y)}{\partial w_{47}} &= \frac{\partial Loss(a_7, y)}{\partial a_7} * \frac{\partial a_7}{\partial z_7} * \frac{\partial z_7}{\partial w_{47}} \ =\frac{\partial Loss(a_7, y)}{\partial a_7} * \frac{\partial a_7}{\partial z_7} * a_4 \end{align}
$$
同样地：
$$
\begin{align} \frac{\partial Loss(a_7,y)}{\partial w_{57}} = \frac{\partial Loss(a_7, y)}{\partial a_7} * \frac{\partial a_7}{\partial z_7} * \frac{\partial z_7}{\partial w_{57}} \ =\\ \frac{\partial Loss(a_7, y)}{\partial a_7} * \frac{\partial a_7}{\partial z_7} * a_5 \ \frac{\partial Loss(a_7,y)}{\partial w_{67}} = \frac{\partial Loss(a_7, y)}{\partial a_7} * \frac{\partial a_7}{\partial z_7} * a_6 \end{align}
$$
由于 $a_4 = a_5 = a_6$，则有：
$$
\frac{\partial Loss(a_7,y)}{\partial w_{47}} = \frac{\partial Loss(a_7,y)}{\partial w_{57}} = \frac{\partial Loss(a_7,y)}{\partial w_{67}} = \Delta w 
$$
权重更新表达式为：
$$
w_{47}^{'} = w_{47} + \Delta w \ w_{57}^{'} = w_{57} + \Delta w \ w_{67}^{'} = w_{67} + \Delta w 
$$
由于 $w_{47}、w_{57}、w_{67}$ 的初始值均为0，那么：
$$
w_{47}^{'} = w_{57}^{'} = w_{67}^{'}\\w_{14}^{'} = w_{24}^{'} = w_{34}^{'} = w_{14}^{'} = w_{25}^{'} = w_{26}^{'} = w_{34}^{'} = w_{35}^{'} = w_{36}^{'}
$$
由此可见，更新后的参数在每一层内都是相同的。同时，无论经过多少次网络训练，相同网络层内的参数值都是相同的，这会导致网络在学习时没有重点，对所有的特征处理相同，这很可能导致模型无法收敛训练失败。这种现象被称为对称失效。

同样地，当权重被初始化为相同的非零值时，也会出现上述情况，此时神经网络模型和一个线性模型的效果相似，失去了神经网络提取特征的意义。

2. 高斯分布初始化

一种非常常见的方式是采用高斯分布，其分布的大小对于优化过程的结果和网络泛化能力都有很大影响。

使用一个均值为 $\mu$，方差为 $\sigma^2$ 的高斯分布 $N(\mu, \sigma^2)$ 对每个参数进行随机初始化，通常情况下，$\mu = 0$，并对生成的数乘上一个小数，把权重初始化为很小的随机数。比如：$w = 0.01 * np.random.rand(D,H)$，这里选择乘以0.01初始化为一个很小的数是因为，如果最初随机到的 $w$ 值很大，当我们选择 sigmoid 或 tanh 激活函数时，函数值 $sigmoid(\cdot)$ 或 $tanh(\cdot)$ 会停留在一个很平坦的地方，激活值接近饱和，导致梯度下降时，梯度很小，学习变得缓慢。但也不是说权重值越小越好，如果权重值过小，会导致在反向传播时计算得到很小的梯度值，在不断的反向传播过程中，引起梯度消失。

3. kaiming 初始化

有名的何恺明初始化。pytorch 对 conv2d 的默认初始化采用了 kaiming 初始化，这种初始化能很好的适配 ReLU 激活函数。假定使用ReLU激活函数时，网络每一层都中有一半的神经元被激活，另一半为0，因此其分布的方差也近似为恒等函数的一半。这样在考虑前向传播和反向传播时则有：
$$
{\forall}i, \quad \frac12 n_i * Var(W_i) = 1\ {\forall}i, \quad \frac12 n_{i+1} * Var(W_i) = 1
$$
 $W_i$ 的理想方差为：
$$
 {\forall}i, \quad Var(W_i) = \frac{2}{n_i} 
$$


   当采用高斯分布时，则权重可按照 $N(0, \frac{2}{n_i})$ 的高斯分布来进行初始化。若采用在区间 $[-r, r]$ 的均匀分布进行初始化，则初始化分布有：

$$
W \sim U[- \frac{\sqrt 6}{\sqrt{n_i}}, \frac{\sqrt 6}{\sqrt{n_i}}]
$$
   具体论文参见：[Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification](https://arxiv.org/pdf/1502.01852.pdf)

4. Xavier初始化

Xavier初始化，即 0 均值初始化遵循了Bradley（2009）的理论环境，假设网络中的每一层的激活函数都是关于0对称的线性激活函数，权重间的初始化和输入特征相互独立，且均值都为0。

假设在一个神经网络中，对于一层线性网络，其表示为：
$$
y = f(z_1W_1 + z_2W_2 + z_3W_3 + ... + z_iW_i + b) 
$$

$z_i$ 代表该层网络的第 $i$ 个神经元，$y$ 为该层网络的输出，$W_i$ 为本层网络的权重，$b$ 为偏置，$f(\cdot)$ 为激活函数。这里我们假设激活函数为恒等函数，即 $f(x) = x$，导数为1。

对于其中的每个 $z_iW_i$，其方差为：
$$
Var(z_iW_i) = E(z_i)^2Var(W_i) + E(W_i)^2Var(z_i)+Var(z_i)Var(W_i) 
$$
由于 $W_i$ 和 $z_i$ 的均值都为0，因此可以得到：
$$
Var(z_iW_i) = Var(z_i)Var(W_i)
$$
又因为 $z$ 和 $W$ 相互独立，则有：
$$
Var(y) = n_i * Var(z_i)Var(W_i)
$$
其中，$n_i$ 代表第 $i$ 层的神经元数量。

通过上面的公式我们可以发现，输入 $z_i$ 的方差和输出 $y$ 方差相差 $n * Var(W_i)$ 倍，也就是说输入信号在经过神经元后会被放大或缩小 $n * Var(W_i)$ 倍。为保证经过多层网络后，信号不被过分的放大或缩小，我们需要尽可能保证前向传播和反向传播时每层方差保持一致，则有：
$$
{\forall}i, \quad n_i * Var(W_i) = 1\ {\forall}i, \quad n_{i+1} * Var(W_i) = 1 
$$
权衡上述两个限制，提出一个折中的办法：
$$
{\forall}i, \quad Var(W_i) = \frac{2}{n_i + n_{i+1}}
$$
根据计算出的理想方差，可选择通过高斯分布或均匀分布来随机初始化参数。若采用高斯分布，则权重可按照 $N(0, \frac{2}{n_i + n_{i+1}})$ 的高斯分布来进行初始化。若采用在区间 $[-r, r]$ 的均匀分布进行初始化，则初始化分布有：
$$
W \sim U[- \frac{\sqrt 6}{\sqrt{n_i + n_{i+1}}}, \frac{\sqrt 6}{\sqrt{n_i + n_{i+1}}}] 
$$


Xavier 初始化因为基本保证了输入和输出的方差一致，使得样本空间和类别空间的分布差异相似，因此使得模型的训练速度和分类性能获得提升。但xavier初始化的推导基于激活函数是线性的假设，使其并不适合于ReLU、sigmoid等非线性激活函数。

具体论文参见：[Understanding the difficulty of training deep feedforward neural networks](http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf)

5. 正交初始化

将权重初始化为正交矩阵。对于训练非常深的网络很有用。可用于帮助 RNN 中的梯度消失和爆炸。首先利用 torch 生成一个随机数矩阵，X（例如从正态分布），而后执行 QR 分解 X = QR，得到一个正交矩阵 Q 和一个上三角矩阵 R，最后用所得到的 Q 矩阵初始化。

## 过拟合问题

产生过拟合的原因可能有：

1. 训练集上数据量不够大。

2. 参数量过大、模型过于复杂容易导致模型学习到非共性的特征，从而导致泛化能力下降，出现过拟合。

3. 训练程度不够，提早结束。

对此，有如下方案：

1. 适当简化模型，减小参数量，此即 dropout 方法。
2. 增加训练数据的规模来解决。也可以适用 data augmentation 将已有数据做不影响真实类别标签的微小变换产生类似的新数据，变相增大数据量。
3. 通过观察 loss 和验证集上正确率的变化趋势提前停止训练，并选择 loss 几乎最小，而验证集上正确率几乎最大的模型作为最终模型的方法。
4. 正则化：通过在 loss 中增加惩罚项，限制了非线性函数中高次项系数的大小，相当于避免了其过于复杂，从而提高泛化能力。

# 模型对比

前文所述：

> - RNN 的损失值下降最快，收敛最快，正确率在 Text-CNN 与 MLP 之间，然而过拟合现象出现最快
> - CNN 的损失值下降居中，正确率最高，过拟合现象最不明显（经过 100 个 epoch 的实验证明，Text-CNN 的正确率从 25 个 epoch 左右开始收敛到 0.847）
> - MLP 损失函数下降速度、收敛速度最慢，正确率最低，过拟合的程度居于 Text-CNN 与 RNN 之间。

综上可以总结如下：

|      | RNN                                                          | CNN                                        | MLP                                                          |
| ---- | ------------------------------------------------------------ | ------------------------------------------ | ------------------------------------------------------------ |
| 优点 | 输入长度可变且有序（输入携带了时序信息）                     | 可以并行计算，计算速度快；可以提取局部特征 | 可并行计算，计算速度快，模型简单易上手                       |
| 缺点 | 有序性导致其不能并行计算，计算速度慢；梯度不稳定，容易梯度消失 | 输入长度固定，可能丢失语义信息             | 输入长度固定，可能丢失语义信息；模型上限显著，表达性不高：参数量小时表达能力不够，而为了提取更多特征增大隐藏层维数时又容易使参数量过大，导致参数利用率偏低 |

# 关于 Bert

久仰 transformer 与 bert 的大名，我相信 BERT 已经在海量数据中训练，较好地学习到了词汇的语义，最终在此任务上只需要最后加一个简单的线性层做分类就能达到很好的效果。

但是这实际上抛弃 wiki_word2vec_50.bin 词向量嵌入文件，远超出了此次实验范围。我相信此次实验如若使用 bert 来完成，可以突破 90% 这一大关。

# 心得体会

纸上得来终觉浅，绝知此事要躬行。在马老师的课堂上与平日实验室的工作当中，我对模型参数的初始化并不太在意，甚至我并不了解模型何时应该初始化参数，何时不必初始化。

在这次实验中，我首先完成了 CNN 与 RNN，这两个模型都没手动初始化。我认为这些模型默认就是不必初始化的，实际上是我没认识到 pytorch 已经采用了高效的 kaiming 初始化。

直到我完成 MLP 的模型才发现我起初完全错误的全 0  初始化与全 1 初始化导致了对称失效，失去了模型的表达力。我这才发现需要利用高斯初始化。转而查阅资料，我才认识到了 CNN 与 RNN 已经默认了初始化。

若非本次动手实验，这样精妙的细节可能会一直被我抛之脑后，直到在研究中因为这样基础的漏洞而发生严重的问题。所幸通过本次实验，我及时补上了这一漏洞，而且对参数初始化有了自己的认知。

从马老师的课堂所讲解的理论出发，本次实验完整的实现了一次神经网络的训练过程。从数据加载，模型构建，设置训练方式与损失函数，梯度反向传播等等角度，给予了我对于课堂知识更丰富的理解，也让我意识到了深入学习 numpy pytorch 等工具的重要性。

除此之外，借助 wandb，我高效地实现了精美全面的可视化，加深了对深度学习中关键问题的理解，掌握了完成深度学习任务的基本流程。
